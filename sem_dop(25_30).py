# -*- coding: utf-8 -*-
"""sem_dop(25-30)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HNTpmzfL5V4jCCPTNTlxH26OJnuqvy8x

№25
Класс – целочисленный вектор фиксированной размерности. Методы – сумма, разность, скалярное произведение векторов. Поля – размерность вектора, координаты вектора.
"""

class vector:
  def __init__(self,size,coordinates):
    self.size=size
    self.coordinates=coordinates

  def summa(self, othervector):
    if self.size!=othervector.size:
      print('Векторы разной длины')
      return None
    result=[self.coordinates[i]+othervector.coordinates[i]for i in range (self.size)]
    return vector(self.size,result)

  def minus(self, othervector):
    if self.size!=othervector.size:
      print('Векторы разной длины')
      return None
    result=[self.coordinates[i]-othervector.coordinates[i]for i in range (self.size)]
    return vector(self.size,result)

  def dot_product(self, other_vector):
    if self.size != other_vector.size:
          print("Размерности векторов не совпадают")
          return None
    result = sum([self.coordinates[i] * other_vector.coordinates[i] for i in range(self.size)])
    return result

vector1 = vector(3, [1, 2, 3])
vector2 = vector(3, [4, 5, 6])
sum_vector = vector1.summa(vector2)
print("Сумма векторов:", sum_vector.coordinates)

difference_vector = vector1.minus(vector2)
print("Разность векторов:", difference_vector.coordinates)

dot_product_result = vector1.dot_product(vector2)
print("Скалярное произведение векторов:", dot_product_result)

"""№26 Опишите класс Date, заданный тремя атрибутами для года, месяца и дня. Включите в описание класса методы, позволяющие вычислить дату следующего дня, определить, сколько дней осталось до конца месяца, и свойство, позволяющее выяснить, является ли год високосным."""

class Date:
    def __init__(self, year, month, day):
        self.year,self.month,self.day = year,month,day

    def next_day(self):
        days_in_month = [31, (28 if not self.is_leap() else 29), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        if self.day < days_in_month[self.month - 1]:
            self.day += 1
        elif self.day == days_in_month[self.month - 1] and self.month != 12:
            self.day = 1
            self.month += 1
        else:
            self.day = 1
            self.month = 1
            self.year += 1

    def days_until_end_of_month(self):
        days_in_month = [31, 28 if not self.is_leap() else 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        return days_in_month[self.month - 1] - self.day

    def is_leap(self):
        if (self.year % 4 == 0) and ((self.year % 100 != 0) or (self.year % 400 == 0)):
            return True
        else:
            return False

date = Date(2022, 9, 20)
date.next_day()
print(f"Следующий день: {date.year}-{date.month}-{date.day}")

print(f"Дней до конца месяца: {date.days_until_end_of_month()}")

if date.is_leap():
    print("Год високосный")
else:
    print("Год не високосный")

"""№27 Создайте класс ТЕЛО с методами вычисления площади поверхности и объема, а также методом, выводящим информацию о фигуре на экран. Создайте дочерние классы ПАРАЛЛЕЛЕПИПЕД, ШАР, ПИРАМИДА со своими методами вычисления площади и объема. Создайте список  n  фигур и выведите полную информацию о фигурах на экран."""

import math

class Shape:
    def area(self):
        pass
    def volume(self):
        pass

class Cub(Shape):
    def __init__(self, length, width, height):
        self.length, self.width, self.height = length, width, height
    def area(self):
        return 2 * (self.length * self.width + self.width * self.height + self.height * self.length)
    def volume(self):
        return self.length * self.width * self.height

class Sphere(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 4 * math.pi * self.radius ** 2
    def volume(self):
        return (4/3) * math.pi * self.radius ** 3

class Pyramid(Shape):
    def __init__(self, base_length, base_width, height):
        self.base_length, self.base_width, self.height = base_length, base_width, height
    def area(self):
        base_area = self.base_length * self.base_width
        side_area = self.base_length * math.sqrt((self.base_width/2)**2 + self.height**2) + \
                    self.base_width * math.sqrt((self.base_length/2)**2 + self.height**2)
        return base_area + side_area
    def volume(self):
        return (1/3) * self.base_length * self.base_width * self.height

shapes = [Cub(2, 3, 4), Sphere(5), Pyramid(6, 7, 8)]

for shape in shapes:
    print(f"{type(shape).__name__}\n Площадь: {shape.area()} Объем: {shape.volume()}")

"""№28 а) Найти пересечение двух заданных списков с помощью лямбда- функции. Пример: [1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9] → [1, 2, 8, 9].

б) Найти список с максимальной и минимальной длиной, используя лямбда-функцию. Пример: [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] → (3, [13, 15, 17]), (1, [0]).

в) Найти вложенные элементы списков, которые присутствуют в другом списке с помощью лямбда-функции. Пример: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]] → [[12], [7, 11], [1, 5, 8]].
"""

list1 = [1, 2, 3, 5, 7, 8, 9, 10]
list2 = [1, 2, 4, 8, 9]

intersection = list(filter(lambda x: x in list1, list2))
print(intersection)

lists = [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]

max_length_list = max(lists, key=lambda x: len(x))
min_length_list = min(lists, key=lambda x: len(x))

result = (len(max_length_list), max_length_list), (len(min_length_list), min_length_list)
print(result)

main_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
sub_lists = [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]]

result = list(map(lambda sub_list: list(filter(lambda x: x in main_list, sub_list)), sub_lists))
print(result)

"""№29 а) Напишите программу для подсчета пар одинаковых значений в двух заданных списках. Используйте функцию map(). Пример: [1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9] → 4.

б) Сгенерировать список целых чисел. С помощью функции filter() выбрать из списка все числа кратные заданному числу и упорядочить их по убыванию. Используя функцию reduce(), найти их сумму.
"""

list1 = [1, 2, 3, 4, 5, 6, 7, 8]
list2 = [2, 2, 3, 1, 2, 6, 7, 9]

result = sum(map(lambda x, y: x == y, list1, list2))
print(result)

from functools import reduce

# Генерируем список целых чисел
numbers = [i for i in range(1, 101)]

# Заданное число, кратные которому мы будем искать
multiple_of = 7

# Фильтруем числа, оставляем только кратные multiple_of и сортируем их по убыванию
filtered_numbers = sorted(filter(lambda x: x % multiple_of == 0, numbers), reverse=True)

# Находим сумму отфильтрованных чисел с помощью reduce()
sum_of_filtered_numbers = reduce(lambda x, y: x + y, filtered_numbers)

print(filtered_numbers)
print("Сумма отфильтрованных чисел:", sum_of_filtered_numbers)

"""№30 а) Создайте декоратор, который будет заменять исключения, возникающие при выполнении функции, на заданное значение и логировать эти замены.

б) Создайте декоратор, который будет заменять значение аргумента на результат выполнения заданной функции только если оно удовлетворяет определенному условию.
"""

import logging

# Настройка логгирования
logging.basicConfig(level=logging.INFO)

def replace_exception(replacement_value):
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                logging.error(f"Exception caught: {e}. Replacing with value: {replacement_value}")
                return replacement_value
        return wrapper
    return decorator

# Пример использования декоратора
@replace_exception("REPLACEMENT_VALUE")
def divide(a, b):
    return a / b

# Примеры вызова функции
print(divide(10, 2))  # Выведет 5.0 (без исключений)
print(divide(10, 0))  # Выведет REPLACEMENT_VALUE (деление на ноль, замена значения)

import logging

logging.basicConfig(level=logging.INFO)  # Установка уровня логирования

def exception_handler(replace_value):
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                logging.warning(f"Исключение {e} заменено на {replace_value}")
                return replace_value

        return wrapper

    return decorator

# Пример использования декоратора
@exception_handler(replace_value="Замененное значение")
def divide(a, b):
    return a / b

# Вызов функции
result = divide(10, 0)
print(result)

def conditional_decorator(condition, new_value):
    def decorator(func):
        def wrapper(arg):
            if condition(arg):
                return func(new_value)
            return func(arg)
        return wrapper
    return decorator

# Пример использования декоратора
def square(x):
    return x ** 2

# Условие: значение аргумента больше 5
condition_func = lambda x: x > 5
decorated_square = conditional_decorator(condition_func, 10)(square)

# Примеры вызова функции
print(decorated_square(4))  # Выведет 4 (не удовлетворяет условию, значение не изменяется)
print(decorated_square(6))  # Выведет 100 (удовлетворяет условию, значение заменено)