#!/usr/bin/env python
# coding: utf-8

# # Решение 

# Задача 1

# Реализовать программу, с которой можно играть в логическую игру «Быки и коровы» (описание правил игры: http://робомозг.рф/Articles/BullsAndCowsRules ). Программа загадывает число, пользователь вводит очередной вариант отгадываемого числа, программа возвращает количество быков и коров и в случае выигрыша игрока сообщает о победе и завершается. Сама программа НЕ ходит, т.е. не пытается отгадать число загаданное игроком.
# Взаимодействие с программой производится через консоль, при запросе данных от пользователя программа сообщает, что ожидает от пользователя и проверяет корректность ввода.

# In[ ]:


from random import* #подключаем библиотеку для задания рандомных чисел
from itertools import permutations #подключаем возможность задать перестановки
w=[]
for i in permutations('0123456789',r=4): #рассматриваем все возмодные комбинации четырехзнчных чисел
    a=''.join(i)
    w.append(a) #записываем комбинации в массив
chislo=choice(w) #выбираем случайное число из этого массива
win=False 
while not win: #запускаем цикл который будет выполняться до победы
    hod=input('Введите четырёхзначное число: ') #вводим число
    while len(hod)!=4 or hod.isdigit()==False or len(set(hod))!=4: #проверяем корректность ввода, если введено неправильно просим повторить ввод
            hod=input('Введено некорректное значение. Пробуйте снова: ')
    cows=0 #создаем переменную для подсчета коров
    bulls=0 #создаем переменную для подсчета быков
    for i in range(len(chislo)): #проходимся пополученному числу и проверяем совпадение с загаданным числом
        if hod[i]==chislo[i]:
            bulls+=1
        elif hod[i] in chislo:
            cows+=1
    print(str(bulls) + ' быка и ' + str(cows) + ' коровы') #выводим количество коров и быков
    if bulls==4: #проверка на победу
        win=True
print('Вы победили.')


# Задача 2

# Реализовать программу, при помощи которой 2 игрока могут играть в «Крестики-нолики» на поле 3 на 3. Взаимодействие с программой производится через консоль. Игровое поле изображается в виде трех текстовых строк и перерисовывается при каждом изменении состояния поля. При запросе данных от пользователя программа сообщает, что ожидает от пользователя (в частности, координаты новой отметки на поле) и проверяет корректность ввода. Программа должна уметь автоматически определять, что партия окончена, и сообщать о победе одного из игроков или о ничьей. Сама программа НЕ ходит, т.е. не пытается ставить крестики и нолики с целью заполнить линию.

# In[ ]:


maps=list(range(1,10)) #обозначаем кол-во ячейек для крестиков ноликов
victory=[[0,1,2], #выигрышные комбинации
         [3,4,5],
         [6,7,8],
         [0,3,6],
         [1,4,7],
         [2,5,8],
         [0,4,8],
         [2,4,6]]
def print_maps(): #функция для печати таблицы
    for i in range (3): #поочередно выводим строки таблицы
        print(maps[i*3+0],maps[i*3+1],maps[i*3+2])
def input_maps(): #функция для ввода значений
    if igrok==False: #проверка какой игрок ходит
        igroks='X'
    else:
        igroks='O'
    hod=input('Ваш ход игрок '+ igroks + ' ')
    while (hod not in '123456789') or (int(hod) not in maps) : #пороверка на корректность ввода
        hod=input('Введено неверное значение. Еще раз ваш ход '+ igroks + ' ')
    maps[int(hod)-1]=igroks #замена цифры в таблице крестиком или ноликом
        
def proverka_win(): #проверка на победу
    win='никто'
    for i in victory: #проходимся по списку выигрышных комбинаций
        for i in victory:
            if (maps[i[0]]==maps[i[1]]==maps[i[2]]):
                if igrok==False:
                    win='X'
                else:
                    win='O'
                    break
    return win     
count=9
igrok=False
win='никто' 
while win =='никто' and count!=0:
    print_maps()
    input_maps()
    win = proverka_win()
    igrok=not igrok
    count-=1
print('Выиграл игрок '+ win)


# Задача 3

# Реализовать программу, при помощи которой 2 игрока могут играть в игру «Супер ним». Правила игры следующие. На шахматной доске в некоторых клетках случайно разбросаны фишки или пуговицы. Игроки ходят по очереди. За один ход можно снять все фишки с какой-либо горизонтали или вертикали, на которой они есть. Выигрывает тот, кто заберет последние фишки. (описание правил игры: https://www.iqfun.ru/articles/super-nim.shtml )
# Взаимодействие с программой производится через консоль. Игровое поле изображается в виде текстовых строк и перерисовывается при каждом изменении состояния поля. При запросе данных от пользователя программа сообщает, что ожидает от пользователя (в частности, координаты новой отметки на поле) и проверяет корректность ввода. Программа должна уметь автоматически определять, что партия окончена, и сообщать о победе одного из игроков. Сама программа НЕ ходит, т.е. не пытается выбирать строки или столбцы с целью победить в игре.
# 

# In[ ]:


import random #подключаем библиотеку для задания рандомных значений
maps=[[0,0,0,0,0,0,0,0], #создаем двумерный массив в котором будут хранится игровое поле
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],
     [0,0,0,0,0,0,0,0],]

for i in range (8): #перебираем элементы массива  и заменчем из рандомными значениями
    for j in range (8): 
        maps[i][j]=random.choice([0,1])

def print_maps(): #создаем функцию для вывода игрового поля
    print('   a  b  c  d  e  f  g  h') #воводим номера столбцов
    for i in range (8):
        print (i+1,maps[i]) #выводим номер строки и элемент массива в столбик

def input_hod(): #создаем функцию для ввода значений и их обработки
    error=True #создаем переменную для проверки на ошибку
    while error: #создаем цикл, чтобы в случае ввода неправильного значения запрашивался бы еще одно
        hod=input('Игрок ' +name_igrok()+ ' Введите ваш ход (строку или столбец) ') #ввод значения
        error=False #после ввода значения считаем, что ошибки нет
        if len(hod)!=1 or hod not in '12345678abcdefgh': # проверяем, чтобы введен был номер столбца или строки
            error=True
        if not error : #если введенно корректное значение, но строка или столбец состоит только из нулей, то просим ввести значение еще раз
            if hod in '12345678':
                if maps[int(hod)-1].count(1)==0:
                    error=True
            else:
                count=0
                for i in range (8):
                    count+=maps[i]["abcdefgh".index(hod)] 
                if count==0:
                    error=True                    
            
    if hod in '12345678': #обработка хода в случае введения строки
        for i in range (8): #замена всех значений строки на нули
                maps[int(hod)-1][i]=0
    if hod in 'abcdefgh': #обработка хода в случае введения столбца
        for i in range (8):#замена всех значений столбца на нули
                maps[i]["abcdefgh".index(hod)]=0     
def proverka_win(): #создаем функцию для проверки на победу
    count=0 #создаем переменную для подсчета единиц
    for i in range (8): #проходимся циклом по массиву и считаем колличество единиц
        count+=maps[i].count(1)
    if count==0: #если колличество кдиниц равно нулю то игровое поле пусто
        return True 
    else:
        return False   

def name_igrok(): #создаем функцию для определения игрока
    if igrok==False:
        return '1'
    else:
        return '2'
win=False #создаем переменную для отслеживания победы
igrok=True #создаем переменную для отслеживания какой игрок ходит
while win==False: #создаем цикл, который вызывает функции пока не кто-нибудь не победит
    igrok=not igrok #смена игрока
    print_maps()
    input_hod()
    win=proverka_win() 
print('Выиграл игрок '+name_igrok()) #выводим победителя


# Задача 4

# Реализовать программу, с которой можно играть в игру «19». Правила игры следующие. Нужно выписать подряд числа от 1 до 19: в строчку до 9, а потом начать следующую строку, в каждой клетке по 1 цифре (не числу (см пример по ссылке)). Затем игроку необходимо вычеркнуть парные цифры или дающие в сумме 10. Условие -  пары должны находиться рядом или через зачеркнутые цифры по горизонтали или по вертикали. После того как все возможные пары вычеркнуты, оставшиеся цифры переписываются в конец таблицы. Цель - полностью вычеркнуть все цифры. (описание правил игры: http://podelki-fox.ru/igry-dlya-detey-na-bumage-s-chislami/ )
# Взаимодействие с программой производится через консоль. Игровое поле изображается в виде трех текстовых строк и перерисовывается при каждом изменении состояния поля. При запросе данных от пользователя программа сообщает, что ожидает от пользователя (в частности, координаты очередного хода) и проверяет корректность ввода. Программа должна уметь автоматически определять, что нужно выписать новые строки с цифрами и то, что партия окончена. Сама программа НЕ ходит, т.е. не пытается выбирать пары цифр с целью окончить игру.
# 

# In[ ]:


maps='123456789111213141516171819'
variants=[]
    
def print_maps():
    print('abcdefghi')
    for i in range ((len(maps)-1)//9+1):
        if len(maps[i*9:i*9+9])<9:
            print(maps[i*9:i*9+9]+' '*(9-len(maps[i*9:i*9+9])),'|'+str(i))
        else:
            print(maps[i*9:i*9+9],'|'+str(i))

def input_hod():
    error =True
    while error:
        a1=input("Введите координаты первого числа (столбец и строку) ")
        error=False
        if len(a1)<2:
            error =True
        elif a1[0] not in 'abcdefghi':
            error =True
        elif a1[1:].isdigit()==False or ((len(maps)-1)//9+1)<=int(a1[1:]):
            error =True
        elif not proverka_hoda1(a1):
            error =True
    error =True
    while error:
        a2=input("Введите координаты второго числа (столбец и строку) ")
        error=False
        if len(a2)<2:
            error =True
        elif a2[0] not in 'abcdefghi':
            error =True
        elif a2[1:].isdigit()==False or ((len(maps)-1)//9+1)<=int(a2[1:]):
            error =True
        elif not proverka_hoda12(a1,a2):
            error =True
    i1=adr_el_maps(a1)
    i2=adr_el_maps(a2)
    maps1=maps[:i1]+"-"+maps[i1+1:]
    maps1=maps1[:i2]+"-"+maps1[i2+1:]
    return maps1

# Проверка на правильность первого хода
def proverka_hoda1(xy):
    resultat=False
    axy=adr_el_maps(xy)
    for i in variants:
        if i[0]==axy or i[1]==axy:
            resultat=True
            break   
    return resultat

# Проверка на правильность первого и второго хода
def proverka_hoda12(xy1,xy2):
    resultat=False
    axy1=adr_el_maps(xy1)
    axy2=adr_el_maps(xy2)
    for i in variants:
        if (i[0]==axy1 and i[1]==axy2) or (i[0]==axy2 and i[1]==axy1):
            resultat=True
            break   
    return resultat

# Пересборка вариантов хода
def creat_variants():
    variants.clear()
    for i in range(len(maps)):
        var=proverka_variant(i)
        if var[1]<var[0]:
            variants.append([i,var[1]])
        if var[2]<var[0]:
            variants.append([i,var[2]])

# Возвращает массив, где первый элемент кол-во эл-в массива maps, второй и третий возможные варианты хода вправо и вниз соответственно
# Причем, если 2 или 3 элементы массива равны первому (те вне массива maps), то элемент не прошел проверку (вариант не найден)
# Условие проверки это равенство суммы элементов maps[adr] и найденно элемента по условию. Условие это пустые значения между элементами.
def proverka_variant(adr):
    var=[len(maps),len(maps),len(maps)]
    if maps[adr]!="-":
        i_count=len(maps)
        i=adr+1
        while i<i_count and maps[i]=="-" :
            i+=1
        if i<i_count and (maps[adr]==maps[i] or (int(maps[adr])+int(maps[i]))==10) and (i//9)==(adr//9):  
            var[1]=i
        i=adr+9
        while i<i_count and maps[i]=="-":
            i+=9
        if i<i_count and (maps[adr]==maps[i] or (int(maps[adr])+int(maps[i]))==10):  
            var[2]=i
    return var

#Позиция элемента в массиве maps в соответствии с координатами
def adr_el_maps(xy):
    x= 'abcdefghi'.index(xy[0])
    y=int(xy[1:])
    return y*9+x

def read_el_maps(xy):
    x= 'abcdefghi'.index(xy[0])
    y=int(xy[1:])
    return maps[y*9+x]

def del_space():
    maps1=maps
    for i in range (len(maps)//9):
        if maps[i*9:i*9+9]=='---------':
            maps1=maps[:i*9]+maps[i*9+9:]
    return maps1

def add_string():
    maps1=maps
    for i in maps:
        if i!='-':
            maps1+=i
    return maps1
            

win=False
while not win:
    print_maps()
    creat_variants()
    if len(variants)>0:
        print('Кол-во возможных вариантов хода ',len(variants))
        maps=input_hod()
        maps=del_space()
    elif maps.replace('-','').isdigit()==True:
        maps=add_string()
    else:
        print('Игра окончена!')
        win=True

